
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>transport: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">

				<option value="file0">github.com/ajitpratap0/mcp-sdk-go/pkg/transport/http.go (0.0%)</option>

				<option value="file1">github.com/ajitpratap0/mcp-sdk-go/pkg/transport/stdio.go (70.3%)</option>

				<option value="file2">github.com/ajitpratap0/mcp-sdk-go/pkg/transport/streamable_http.go (0.0%)</option>

				<option value="file3">github.com/ajitpratap0/mcp-sdk-go/pkg/transport/transport.go (86.9%)</option>

				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>

				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>

			</div>
		</div>
		<div id="content">

		<pre class="file" id="file0" style="display: none">package transport

import (
        "bufio"
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "sync"
        "sync/atomic"
        "time"

        "github.com/ajitpratap0/mcp-sdk-go/pkg/protocol"
)

// HTTPTransport implements Transport using HTTP with Server-Sent Events (SSE)
type HTTPTransport struct {
        *BaseTransport
        serverURL       string
        client          *http.Client
        eventSource     *EventSource
        running         atomic.Bool
        options         *Options
        headers         map[string]string
        requestIDPrefix string
        mu              sync.Mutex
}

// EventSource is a client for Server-Sent Events
type EventSource struct {
        URL         string
        Headers     map[string]string
        Client      *http.Client
        Connection  *http.Response
        MessageChan chan []byte
        ErrorChan   chan error
        CloseChan   chan struct{}
        mu          sync.Mutex
        isConnected atomic.Bool
}

// NewHTTPTransport creates a new HTTP transport
func NewHTTPTransport(serverURL string, options ...Option) *HTTPTransport <span class="cov0" title="0">{
        opts := NewOptions(options...)

        client := &amp;http.Client{
                Timeout: opts.RequestTimeout,
        }

        return &amp;HTTPTransport{
                BaseTransport:   NewBaseTransport(),
                serverURL:       serverURL,
                client:          client,
                options:         opts,
                headers:         make(map[string]string),
                requestIDPrefix: "http",
        }
}</span>

// SetRequestIDPrefix sets the prefix for request IDs
func (t *HTTPTransport) SetRequestIDPrefix(prefix string) <span class="cov0" title="0">{
        t.requestIDPrefix = prefix
}</span>

// SetHeader sets a HTTP header for all requests
func (t *HTTPTransport) SetHeader(key, value string) <span class="cov0" title="0">{
        t.mu.Lock()
        defer t.mu.Unlock()
        t.headers[key] = value
}</span>

// Initialize sets up the HTTP transport
func (t *HTTPTransport) Initialize(ctx context.Context) error <span class="cov0" title="0">{
        // Create event source for SSE
        t.eventSource = &amp;EventSource{
                URL:         fmt.Sprintf("%s/events", t.serverURL),
                Headers:     t.headers,
                Client:      t.client,
                MessageChan: make(chan []byte, 100),
                ErrorChan:   make(chan error, 10),
                CloseChan:   make(chan struct{}),
        }

        return nil
}</span>

// SendRequest sends a request and waits for the response
func (t *HTTPTransport) SendRequest(ctx context.Context, method string, params interface{}) (interface{}, error) <span class="cov0" title="0">{
        id := fmt.Sprintf("%s-%d", t.requestIDPrefix, t.GetNextID())

        req, err := protocol.NewRequest(id, method, params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">reqCtx, cancel := context.WithTimeout(ctx, t.options.RequestTimeout)
        defer cancel()

        // Send HTTP request
        if err := t.sendHTTPRequest(req); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to send request: %w", err)
        }</span>

        // Wait for response through SSE channel
        <span class="cov0" title="0">resp, err := t.WaitForResponse(reqCtx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed waiting for response: %w", err)
        }</span>

        <span class="cov0" title="0">if resp.Error != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("server error: %s (code: %d)", resp.Error.Message, resp.Error.Code)
        }</span>

        <span class="cov0" title="0">return resp.Result, nil</span>
}

// SendNotification sends a notification (one-way message)
func (t *HTTPTransport) SendNotification(ctx context.Context, method string, params interface{}) error <span class="cov0" title="0">{
        notif, err := protocol.NewNotification(method, params)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create notification: %w", err)
        }</span>

        <span class="cov0" title="0">return t.sendHTTPRequest(notif)</span>
}

// Start begins processing messages (blocking)
func (t *HTTPTransport) Start(ctx context.Context) error <span class="cov0" title="0">{
        if !t.running.CompareAndSwap(false, true) </span><span class="cov0" title="0">{
                return fmt.Errorf("transport already running")
        }</span>

        <span class="cov0" title="0">defer t.running.Store(false)

        // Connect to SSE endpoint
        if err := t.eventSource.Connect(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to connect to event source: %w", err)
        }</span>

        // Process incoming SSE messages
        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        t.eventSource.Close()
                        return ctx.Err()</span>

                case err := &lt;-t.eventSource.ErrorChan:<span class="cov0" title="0">
                        // Log the error
                        fmt.Printf("EventSource error: %v. Attempting to reconnect...\n", err)

                        // Try to reconnect on error
                        t.eventSource.Close()

                        // Introduce a delay before reconnecting
                        time.Sleep(5 * time.Second)

                        if reconnectErr := t.eventSource.Connect(); reconnectErr != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to reconnect after error %v: %w", err, reconnectErr)
                        }</span>
                        <span class="cov0" title="0">fmt.Println("EventSource reconnected successfully.")</span>

                case data := &lt;-t.eventSource.MessageChan:<span class="cov0" title="0">
                        if err := t.handleMessage(ctx, data); err != nil </span><span class="cov0" title="0">{
                                // Just log errors, don't stop processing
                                fmt.Printf("Error handling message: %v\n", err)
                        }</span>
                }
        }
}

// Stop gracefully shuts down the transport
func (t *HTTPTransport) Stop(ctx context.Context) error <span class="cov0" title="0">{
        if t.eventSource != nil </span><span class="cov0" title="0">{
                t.eventSource.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// sendHTTPRequest sends a JSON-RPC message via HTTP POST
func (t *HTTPTransport) sendHTTPRequest(message interface{}) error <span class="cov0" title="0">{
        data, err := json.Marshal(message)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal message: %w", err)
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequest("POST", t.serverURL, bytes.NewBuffer(data))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create HTTP request: %w", err)
        }</span>

        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")
        for key, value := range t.headers </span><span class="cov0" title="0">{
                req.Header.Set(key, value)
        }</span>

        <span class="cov0" title="0">resp, err := t.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("HTTP request failed: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode &gt;= 400 </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return fmt.Errorf("HTTP error %d: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// handleMessage processes an incoming JSON-RPC message from the SSE stream
func (t *HTTPTransport) handleMessage(ctx context.Context, data []byte) error <span class="cov0" title="0">{
        if protocol.IsRequest(data) </span><span class="cov0" title="0">{
                var req protocol.Request
                if err := json.Unmarshal(data, &amp;req); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to unmarshal request: %w", err)
                }</span>

                <span class="cov0" title="0">resp, err := t.HandleRequest(ctx, &amp;req)
                if err != nil </span><span class="cov0" title="0">{
                        errResp, _ := protocol.NewErrorResponse(req.ID, protocol.InternalError, err.Error(), nil)
                        return t.sendHTTPRequest(errResp)
                }</span>

                <span class="cov0" title="0">return t.sendHTTPRequest(resp)</span>

        } else<span class="cov0" title="0"> if protocol.IsResponse(data) </span><span class="cov0" title="0">{
                var resp protocol.Response
                if err := json.Unmarshal(data, &amp;resp); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to unmarshal response: %w", err)
                }</span>

                <span class="cov0" title="0">t.HandleResponse(&amp;resp)
                return nil</span>

        } else<span class="cov0" title="0"> if protocol.IsNotification(data) </span><span class="cov0" title="0">{
                var notif protocol.Notification
                if err := json.Unmarshal(data, &amp;notif); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to unmarshal notification: %w", err)
                }</span>

                <span class="cov0" title="0">return t.HandleNotification(ctx, &amp;notif)</span>

        } else<span class="cov0" title="0"> {
                return fmt.Errorf("unknown message type: %s", string(data))
        }</span>
}

// Connect establishes a connection to the SSE endpoint
func (es *EventSource) Connect() error <span class="cov0" title="0">{
        es.mu.Lock()
        defer es.mu.Unlock()

        if es.isConnected.Load() </span><span class="cov0" title="0">{
                return nil // Already connected
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequest("GET", es.URL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">req.Header.Set("Accept", "text/event-stream")
        req.Header.Set("Cache-Control", "no-cache")
        for key, value := range es.Headers </span><span class="cov0" title="0">{
                req.Header.Set(key, value)
        }</span>

        <span class="cov0" title="0">resp, err := es.Client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("connection failed: %w", err)
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                if err := resp.Body.Close(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error closing response body: %w", err)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("unexpected status code: %d", resp.StatusCode)</span>
        }

        <span class="cov0" title="0">es.Connection = resp
        es.isConnected.Store(true)

        // Start reading events
        go es.readEvents()

        return nil</span>
}

// Close terminates the SSE connection
func (es *EventSource) Close() <span class="cov0" title="0">{
        es.mu.Lock()
        defer es.mu.Unlock()

        if !es.isConnected.Load() </span><span class="cov0" title="0">{
                return
        }</span>

        // Signal close to readEvents goroutine
        <span class="cov0" title="0">close(es.CloseChan)

        // Close the connection
        if es.Connection != nil &amp;&amp; es.Connection.Body != nil </span><span class="cov0" title="0">{
                if err := es.Connection.Body.Close(); err != nil </span><span class="cov0" title="0">{
                        // Just log the error as we're already in a cleanup path
                        fmt.Printf("Error closing connection body: %v\n", err)
                }</span>
                <span class="cov0" title="0">es.Connection = nil</span>
        }

        <span class="cov0" title="0">es.isConnected.Store(false)</span>
}

// readEvents processes the SSE stream
func (es *EventSource) readEvents() <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                if es.Connection != nil &amp;&amp; es.Connection.Body != nil </span><span class="cov0" title="0">{
                        if err := es.Connection.Body.Close(); err != nil </span><span class="cov0" title="0">{
                                // Just log the error as we're already in a cleanup path
                                fmt.Printf("Error closing connection body: %v\n", err)
                        }</span>
                }
                <span class="cov0" title="0">es.isConnected.Store(false)</span>
        }()

        <span class="cov0" title="0">reader := bufio.NewReader(es.Connection.Body)
        var buffer bytes.Buffer

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-es.CloseChan:<span class="cov0" title="0">
                        return</span>
                default:<span class="cov0" title="0">
                        line, err := reader.ReadBytes('\n')
                        if err != nil </span><span class="cov0" title="0">{
                                select </span>{
                                case es.ErrorChan &lt;- fmt.Errorf("read error: %w", err):<span class="cov0" title="0"></span>
                                default:<span class="cov0" title="0"></span>
                                        // Error channel is full, skip
                                }
                                <span class="cov0" title="0">return</span>
                        }

                        // Empty line marks the end of an event
                        <span class="cov0" title="0">if len(line) &lt;= 2 </span><span class="cov0" title="0">{ // Just \r\n or \n
                                if buffer.Len() &gt; 0 </span><span class="cov0" title="0">{
                                        data := buffer.Bytes()
                                        buffer.Reset()

                                        // Skip comments and other SSE-specific lines
                                        if len(data) &gt; 0 &amp;&amp; data[0] != ':' </span><span class="cov0" title="0">{
                                                es.MessageChan &lt;- data
                                        }</span>
                                }
                                <span class="cov0" title="0">continue</span>
                        }

                        // Check for "data:" prefix and append to buffer
                        <span class="cov0" title="0">if bytes.HasPrefix(line, []byte("data:")) </span><span class="cov0" title="0">{
                                buffer.Write(line[5:]) // Skip "data:"
                        }</span>
                }
        }
}

// Send transmits a message over the transport.
// For HTTPTransport, this is not fully applicable since it operates in a request/response model.
// This is here to satisfy the Transport interface.
func (t *HTTPTransport) Send(data []byte) error <span class="cov0" title="0">{
        return fmt.Errorf("Send method not applicable for HTTPTransport")
}</span>

// SetReceiveHandler sets the handler for received messages.
func (t *HTTPTransport) SetReceiveHandler(handler ReceiveHandler) {<span class="cov0" title="0">
        // This is a placeholder implementation
}</span>

// SetErrorHandler sets the handler for transport errors.
func (t *HTTPTransport) SetErrorHandler(handler ErrorHandler) {<span class="cov0" title="0">
        // This is a placeholder implementation
}</span>
</pre>

		<pre class="file" id="file1" style="display: none">// Package transport provides various transport mechanisms for MCP communication.
package transport

import (
        "bufio"
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "os"
        "runtime/debug"
        "sync"

        "github.com/ajitpratap0/mcp-sdk-go/pkg/protocol"
)

// StdioTransport implements the Transport interface using standard input and output.
// This is the recommended transport mechanism in the MCP specification for command-line
// tools and applications where the client and server are typically connected via pipes.
type StdioTransport struct {
        *BaseTransport               // Embedded BaseTransport
        reader         io.Reader     // Changed from *bufio.Reader for flexibility
        writer         io.Writer     // Changed from *bufio.Writer for flexibility
        rawWriter      *bufio.Writer // Internal buffered writer
        errorHandler   ErrorHandler  // For low-level I/O errors
        mutex          sync.RWMutex  // Protects writer and errorHandler
        done           chan struct{}
        stopOnce       sync.Once // Ensures Stop logic runs once
}

// NewStdioTransport creates a new transport that uses the provided reader and writer.
// This constructor is suitable for testing or custom pipe configurations.
func NewStdioTransport(r io.Reader, w io.Writer) *StdioTransport <span class="cov8" title="1">{
        return &amp;StdioTransport{
                BaseTransport: NewBaseTransport(),
                reader:        r,
                writer:        w,
                rawWriter:     bufio.NewWriter(w),
                done:          make(chan struct{}),
        }
}</span>

// NewStdioTransportWithStdInOut creates a new transport that uses standard input and output.
func NewStdioTransportWithStdInOut() *StdioTransport <span class="cov0" title="0">{
        return NewStdioTransport(os.Stdin, os.Stdout)
}</span>

// Initialize prepares the transport for use.
// For StdioTransport, this is a no-op as the stdin/stdout are already available.
func (t *StdioTransport) Initialize(ctx context.Context) error <span class="cov0" title="0">{
        return nil
}</span>

// Start begins reading messages from stdin and processing them.
// This method blocks until the context is canceled or an error occurs.
func (t *StdioTransport) Start(ctx context.Context) error <span class="cov8" title="1">{
        // Create a scanner for reading lines from the reader
        scanner := bufio.NewScanner(t.reader)

        // Create a channel for the scanner to signal it's done
        scannerDone := make(chan struct{})

        // Set up a goroutine to read from stdin
        SafeGo(t.BaseTransport.Logf, "stdio-scanner", func() </span><span class="cov8" title="1">{
                defer close(scannerDone)

                // Read lines until EOF or error
                for scanner.Scan() </span><span class="cov8" title="1">{
                        // Get the line (should be a complete JSON message)
                        line := scanner.Bytes()

                        // Copy the line to avoid it being overwritten by the next Scan
                        data := make([]byte, len(line))
                        copy(data, line)

                        // Process the message in a goroutine to avoid blocking
                        SafeGo(t.BaseTransport.Logf, "stdio-process-message", func() </span><span class="cov8" title="1">{
                                t.processMessage(data)
                        }</span>)
                }

                // Check for scanner errors
                <span class="cov8" title="1">if err := scanner.Err(); err != nil &amp;&amp; err != io.EOF </span><span class="cov8" title="1">{
                        t.handleError(fmt.Errorf("error reading from input: %w", err))
                }</span>
        })

        // Wait for either the context to be canceled or the scanner to finish
        <span class="cov8" title="1">select </span>{
        case &lt;-ctx.Done():<span class="cov8" title="1">
                return ctx.Err()</span>
        case &lt;-scannerDone:<span class="cov8" title="1">
                return nil</span>
        case &lt;-t.done:<span class="cov8" title="1">
                return nil</span>
        }
}

// Stop halts the transport and cleans up resources.
func (t *StdioTransport) Stop(ctx context.Context) error <span class="cov8" title="1">{
        t.stopOnce.Do(func() </span><span class="cov8" title="1">{
                close(t.done) // Signal all loops relying on t.done to stop
        }</span>)

        <span class="cov8" title="1">t.mutex.Lock()
        defer t.mutex.Unlock()
        if t.rawWriter != nil </span><span class="cov8" title="1">{
                if err := t.rawWriter.Flush(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error flushing writer on stop: %w", err)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// Send transmits a message over the transport.
// For StdioTransport, this writes a line to stdout.
func (t *StdioTransport) Send(data []byte) error <span class="cov8" title="1">{
        // Acquire a lock to prevent concurrent writes
        t.mutex.Lock()
        defer t.mutex.Unlock()

        if t.rawWriter == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("transport writer is not initialized")
        }</span>

        // Write the message followed by a newline
        <span class="cov8" title="1">if _, err := t.rawWriter.Write(data); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error writing to output: %w", err)
        }</span>

        // Write a newline to terminate the message
        <span class="cov8" title="1">if err := t.rawWriter.WriteByte('\n'); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error writing newline to output: %w", err)
        }</span>

        // Flush the buffer to ensure the message is sent
        <span class="cov8" title="1">if err := t.rawWriter.Flush(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error flushing output: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// SetErrorHandler sets the handler for transport errors.
func (t *StdioTransport) SetErrorHandler(handler ErrorHandler) <span class="cov8" title="1">{
        t.mutex.Lock()
        defer t.mutex.Unlock()
        t.errorHandler = handler
}</span>

// processMessage handles a received message by validating it and passing it to the receive handler.
func (t *StdioTransport) processMessage(data []byte) <span class="cov8" title="1">{
        // Recover from panics in message processing
        defer func() </span><span class="cov8" title="1">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        stackTrace := string(debug.Stack())
                        t.BaseTransport.Logf("ERROR: Panic in processMessage: %v\nStack trace:\n%s", r, stackTrace)
                        t.handleError(fmt.Errorf("panic processing message: %v", r))
                }</span>
        }()

        <span class="cov8" title="1">t.BaseTransport.Logf("StdioTransport.processMessage: Received raw data: %s", string(data))
        // Attempt to determine message type by unmarshalling into a generic map
        var genericMsg map[string]interface{}
        if err := json.Unmarshal(data, &amp;genericMsg); err != nil </span><span class="cov8" title="1">{
                t.handleError(fmt.Errorf("error unmarshalling generic message: %w", err))
                t.BaseTransport.Logf("StdioTransport.processMessage: Error unmarshalling generic message: %v. Data: %s", err, string(data))
                return
        }</span>

        <span class="cov8" title="1">_, hasMethod := genericMsg["method"]
        _, hasID := genericMsg["id"]
        // Distinguish between Response (hasID and (hasResult or hasError)) and Request (hasID and hasMethod)
        // Notification hasMethod and (usually) no ID, or if ID is present, no result/error.
        isResponse := hasID &amp;&amp; (genericMsg["result"] != nil || genericMsg["error"] != nil)
        isRequest := hasID &amp;&amp; hasMethod &amp;&amp; !isResponse // Ensure it's not also a response structure
        isNotification := hasMethod &amp;&amp; !hasID          // Simplest notification form

        t.BaseTransport.Logf("StdioTransport.processMessage: Parsed generic: hasMethod=%t, hasID=%t, isResponse=%t, isRequest=%t, isNotification=%t", hasMethod, hasID, isResponse, isRequest, isNotification)

        // More robust check for notifications that might include an ID (though atypical for JSON-RPC notifs)
        if hasMethod &amp;&amp; hasID &amp;&amp; !isRequest &amp;&amp; !isResponse </span><span class="cov0" title="0">{
                t.BaseTransport.Logf("StdioTransport.processMessage: Re-classifying as notification based on robust check")
                isNotification = true
        }</span>

        <span class="cov8" title="1">ctx := context.Background() // Or derive from transport's main context

        if isRequest </span><span class="cov8" title="1">{ // It's a Request
                t.BaseTransport.Logf("StdioTransport.processMessage: Handling as Request. Data: %s", string(data))
                var req protocol.Request
                if err := json.Unmarshal(data, &amp;req); err != nil </span><span class="cov0" title="0">{
                        t.handleError(fmt.Errorf("error unmarshalling request: %w", err))
                        t.BaseTransport.Logf("StdioTransport.processMessage: Error unmarshalling request: %v. Data: %s", err, string(data))
                        return
                }</span>
                <span class="cov8" title="1">resp, err := t.BaseTransport.HandleRequest(ctx, &amp;req)
                if err != nil </span><span class="cov0" title="0">{ // This error is from the handler execution itself
                        t.handleError(fmt.Errorf("HandleRequest for %v returned error: %w", req.ID, err))
                }</span>
                <span class="cov8" title="1">if resp != nil </span><span class="cov8" title="1">{
                        respData, marshalErr := json.Marshal(resp)
                        if marshalErr != nil </span><span class="cov0" title="0">{
                                t.handleError(fmt.Errorf("error marshalling response for request %v: %w", req.ID, marshalErr))
                                return
                        }</span>
                        <span class="cov8" title="1">t.BaseTransport.Logf("StdioTransport.processMessage: Sending response for request %v: %s", req.ID, string(respData))
                        if sendErr := t.Send(respData); sendErr != nil </span><span class="cov0" title="0">{
                                t.handleError(fmt.Errorf("error sending response for request %v: %w", req.ID, sendErr))
                        }</span>
                }

        } else<span class="cov8" title="1"> if isResponse </span><span class="cov8" title="1">{ // It's a Response
                t.BaseTransport.Logf("StdioTransport.processMessage: Handling as Response. Data: %s", string(data))
                var resp protocol.Response
                if err := json.Unmarshal(data, &amp;resp); err != nil </span><span class="cov0" title="0">{
                        t.handleError(fmt.Errorf("error unmarshalling response: %w", err))
                        t.BaseTransport.Logf("StdioTransport.processMessage: Error unmarshalling response: %v. Data: %s", err, string(data))
                        return
                }</span>
                <span class="cov8" title="1">t.BaseTransport.Logf("StdioTransport.processMessage: Calling BaseTransport.HandleResponse for ID %v", resp.ID)
                t.BaseTransport.HandleResponse(&amp;resp)
                t.BaseTransport.Logf("StdioTransport.processMessage: BaseTransport.HandleResponse for ID %v returned", resp.ID)</span>

        } else<span class="cov8" title="1"> if isNotification </span><span class="cov8" title="1">{ // It's a Notification
                t.BaseTransport.Logf("StdioTransport.processMessage: Handling as Notification. Data: %s", string(data))
                var notif protocol.Notification
                if err := json.Unmarshal(data, &amp;notif); err != nil </span><span class="cov0" title="0">{
                        t.handleError(fmt.Errorf("error unmarshalling notification: %w", err))
                        t.BaseTransport.Logf("StdioTransport.processMessage: Error unmarshalling notification: %v. Data: %s", err, string(data))
                        return
                }</span>
                <span class="cov8" title="1">if err := t.BaseTransport.HandleNotification(ctx, &amp;notif); err != nil </span><span class="cov8" title="1">{
                        // For unregistered notification methods, just log the error instead of treating it as a real error
                        // This is common practice for JSON-RPC notifications since they are meant to be fire-and-forget
                        if errors.Is(err, ErrUnsupportedMethod) </span><span class="cov8" title="1">{
                                t.BaseTransport.Logf("Ignoring notification for unregistered method: %s", notif.Method)
                        }</span> else<span class="cov0" title="0"> {
                                // For any other errors during notification handling, report them normally
                                t.handleError(fmt.Errorf("error handling notification %s: %w", notif.Method, err))
                        }</span>
                }

        } else<span class="cov0" title="0"> {
                t.handleError(fmt.Errorf("unknown message type received (method: %v, id: %v, result: %v, error: %v): %s", hasMethod, hasID, genericMsg["result"] != nil, genericMsg["error"] != nil, string(data)))
        }</span>
}

// handleError processes an error by passing it to the error handler if one is set.
func (t *StdioTransport) handleError(err error) <span class="cov8" title="1">{
        // Acquire a read lock to access the handler
        t.mutex.RLock()
        handler := t.errorHandler
        t.mutex.RUnlock()

        // If we have an error handler, use it
        if handler != nil </span><span class="cov8" title="1">{
                handler(err)
        }</span>
}

// GenerateID generates a unique ID for requests.
func (t *StdioTransport) GenerateID() string <span class="cov0" title="0">{
        return t.BaseTransport.GenerateID()
}</span>

// SendRequest sends a request and returns the response
func (t *StdioTransport) SendRequest(ctx context.Context, method string, params interface{}) (interface{}, error) <span class="cov8" title="1">{
        t.Logf("SendRequest: Method=%s, Params=%+v", method, params)
        id := t.BaseTransport.GenerateID()

        // Ensure ID is stored as a string in pendingRequests map before sending the request
        stringID := fmt.Sprintf("%v", id)

        req, err := protocol.NewRequest(stringID, method, params) // Use stringID to ensure consistent type
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error creating request: %w", err)
        }</span>

        <span class="cov8" title="1">bytes, err := json.Marshal(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error marshalling request: %w", err)
        }</span>

        <span class="cov8" title="1">t.Logf("SendRequest: Sending marshalled request: %s", string(bytes))
        if err := t.Send(bytes); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error sending request bytes: %w", err)
        }</span>

        <span class="cov8" title="1">t.Logf("SendRequest: Request sent, waiting for response ID %s", stringID)
        // WaitForResponse should return *protocol.Response or an error
        pResp, err := t.BaseTransport.WaitForResponse(ctx, stringID)
        if err != nil </span><span class="cov0" title="0">{
                t.Logf("SendRequest: Error waiting for response ID %s: %v", stringID, err)
                return nil, fmt.Errorf("error waiting for response: %w", err)
        }</span>

        <span class="cov8" title="1">t.Logf("SendRequest: Received response for ID %s: %+v", stringID, pResp)

        // If the response itself contains a JSON-RPC error, return that error object.
        // The client.Client layer is responsible for interpreting this.
        if pResp.Error != nil </span><span class="cov0" title="0">{
                return nil, pResp.Error // pResp.Error is now a valid error type
        }</span>

        // On success (no transport error, no JSON-RPC error), return the full response object.
        <span class="cov8" title="1">return pResp, nil</span>
}

// SendNotification sends a notification (one-way message)
func (t *StdioTransport) SendNotification(ctx context.Context, method string, params interface{}) error <span class="cov0" title="0">{
        // Note: BaseTransport doesn't have a SendNotification method that directly takes method/params
        // and handles marshaling + sending. It has HandleNotification for incoming.
        // We construct the notification and use StdioTransport's Send.
        notification, err := protocol.NewNotification(method, params)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error creating notification: %w", err)
        }</span>
        <span class="cov0" title="0">jsonData, err := json.Marshal(notification)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error marshalling notification: %w", err)
        }</span>
        <span class="cov0" title="0">return t.Send(jsonData)</span> // Uses StdioTransport's Send to write to stdout
}

// RegisterRequestHandler registers a handler for incoming requests
func (t *StdioTransport) RegisterRequestHandler(method string, handler RequestHandler) <span class="cov8" title="1">{
        t.BaseTransport.RegisterRequestHandler(method, handler)
}</span>

// RegisterNotificationHandler registers a handler for incoming notifications
func (t *StdioTransport) RegisterNotificationHandler(method string, handler NotificationHandler) <span class="cov8" title="1">{
        t.BaseTransport.RegisterNotificationHandler(method, handler)
}</span>

// RegisterProgressHandler registers a handler for progress events
func (t *StdioTransport) RegisterProgressHandler(id interface{}, handler ProgressHandler) {<span class="cov0" title="0">
        // This is a placeholder implementation
}</span>

// UnregisterProgressHandler removes a progress handler
func (t *StdioTransport) UnregisterProgressHandler(id interface{}) {<span class="cov0" title="0">
        // This is a placeholder implementation
}</span>
</pre>

		<pre class="file" id="file2" style="display: none">package transport

import (
        "bufio"
        "bytes"
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "log"
        "net/http"
        "os"
        "strconv"
        "strings"
        "sync"
        "sync/atomic"
        "time"

        "github.com/ajitpratap0/mcp-sdk-go/pkg/protocol"
)

// StreamableHTTPTransport implements Transport using the Streamable HTTP protocol
// which provides advanced features over the basic HTTP+SSE transport like
// resumability, session management, and multiple connection support.
type StreamableHTTPTransport struct {
        *BaseTransport
        endpoint         string
        client           *http.Client
        eventSources     sync.Map // map[string]*StreamableEventSource - multiple connections support
        running          atomic.Bool
        options          *Options
        headers          map[string]string
        requestIDPrefix  string
        sessionID        string
        mu               sync.Mutex
        progressHandlers map[string]ProgressHandler
        responseHandlers map[string]func(*protocol.Response)
        pendingRequests  map[string]chan *protocol.Response
        logger           *log.Logger
}

// StreamableEventSource is an enhanced client for Server-Sent Events
// with support for resumability and event IDs
type StreamableEventSource struct {
        URL         string
        Headers     map[string]string
        Client      *http.Client
        Connection  *http.Response
        MessageChan chan []byte
        ErrorChan   chan error
        CloseChan   chan struct{}
        LastEventID string
        StreamID    string // Unique identifier for this stream
        mu          sync.Mutex
        isConnected atomic.Bool
}

// NewStreamableHTTPTransport creates a new Streamable HTTP transport
func NewStreamableHTTPTransport(endpoint string, options ...Option) *StreamableHTTPTransport <span class="cov0" title="0">{
        opts := NewOptions(options...)

        client := &amp;http.Client{
                Timeout: opts.RequestTimeout,
        }

        return &amp;StreamableHTTPTransport{
                BaseTransport:    NewBaseTransport(),
                endpoint:         endpoint,
                client:           client,
                options:          opts,
                headers:          make(map[string]string),
                requestIDPrefix:  "streamable-http",
                pendingRequests:  make(map[string]chan *protocol.Response),
                progressHandlers: make(map[string]ProgressHandler),
                responseHandlers: make(map[string]func(*protocol.Response)),
                logger:           log.New(os.Stdout, "StreamableHTTPTransport: ", log.LstdFlags),
        }
}</span>

// SetRequestIDPrefix sets the prefix for request IDs
func (t *StreamableHTTPTransport) SetRequestIDPrefix(prefix string) <span class="cov0" title="0">{
        t.requestIDPrefix = prefix
}</span>

// SetHeader sets a HTTP header for all requests
func (t *StreamableHTTPTransport) SetHeader(key, value string) <span class="cov0" title="0">{
        t.mu.Lock()
        defer t.mu.Unlock()
        t.headers[key] = value
}</span>

// SetSessionID sets the session ID for this transport
func (t *StreamableHTTPTransport) SetSessionID(sessionID string) <span class="cov0" title="0">{
        t.mu.Lock()
        defer t.mu.Unlock()
        t.sessionID = sessionID
}</span>

// Initialize sets up the Streamable HTTP transport
func (t *StreamableHTTPTransport) Initialize(ctx context.Context) error <span class="cov0" title="0">{
        // Set default headers
        t.SetHeader("Accept", "application/json, text/event-stream")

        // Create a context with timeout for initialization
        initCtx, cancel := context.WithTimeout(ctx, 30*time.Second)
        defer cancel()

        // Set up session ID tracking
        if t.sessionID != "" </span><span class="cov0" title="0">{
                t.logger.Printf("[DEBUG] Reusing existing session ID: %s\n", t.sessionID)
        }</span>

        // Try to initialize the server connection with a timeout
        // This will establish the session ID if needed
        <span class="cov0" title="0">t.logger.Printf("[DEBUG] Sending initialize request with capabilities\n")
        _, err := t.SendRequest(initCtx, "initialize", map[string]interface{}{
                "clientName":    "Go MCP Client",
                "clientVersion": "1.0.0",
                "capabilities": map[string]bool{
                        "logging":  true,
                        "sampling": true,
                },
        })

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("initialize request failed: %w", err)
        }</span>

        // Log the session ID after initialization
        <span class="cov0" title="0">t.logger.Printf("[DEBUG] Transport has session ID after initialize: %s\n", t.sessionID)

        // Create a listener connection for server-initiated messages
        // This is done in a separate goroutine to not block initialization
        go func() </span><span class="cov0" title="0">{
                err := t.openListenerConnection(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        // Just log the error, don't fail initialization if the server doesn't support GET
                        // as this is optional according to the spec
                        t.logger.Printf("[DEBUG] Failed to open listener connection: %v\n", err)
                }</span>
        }()

        <span class="cov0" title="0">return nil</span>
}

// openListenerConnection opens a GET connection to listen for server-initiated messages
func (t *StreamableHTTPTransport) openListenerConnection(ctx context.Context) error <span class="cov0" title="0">{
        streamID := fmt.Sprintf("listener-%d", time.Now().UnixNano())

        es, err := t.createEventSource(streamID, "", ctx) // Pass ctx here
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">t.eventSources.Store(streamID, es)

        go t.processEventSource(ctx, es)

        return nil</span>
}

// createEventSource sets up a new SSE connection
func (t *StreamableHTTPTransport) createEventSource(streamID string, initialLastEventID string, ctx context.Context) (*StreamableEventSource, error) <span class="cov0" title="0">{
        req, err := http.NewRequestWithContext(ctx, "GET", t.endpoint, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        // Set headers
        <span class="cov0" title="0">req.Header.Set("Accept", "text/event-stream")
        for k, v := range t.headers </span><span class="cov0" title="0">{
                req.Header.Set(k, v)
        }</span>

        // Add session ID if available
        <span class="cov0" title="0">if t.sessionID != "" </span><span class="cov0" title="0">{
                req.Header.Set("MCP-Session-ID", t.sessionID)
        }</span>

        // Add Last-Event-ID if resuming with a specific ID for this stream
        <span class="cov0" title="0">if initialLastEventID != "" </span><span class="cov0" title="0">{
                req.Header.Set("Last-Event-ID", initialLastEventID)
        }</span>

        // Create the event source
        <span class="cov0" title="0">es := &amp;StreamableEventSource{
                URL:         t.endpoint,
                Headers:     t.headers, // Headers for potential reconnections by EventSource itself
                Client:      t.client,
                MessageChan: make(chan []byte, 100),
                ErrorChan:   make(chan error, 10),
                CloseChan:   make(chan struct{}),
                StreamID:    streamID,
                LastEventID: initialLastEventID, // Initialize with the passed ID
        }

        // Connect to the event source
        resp, err := t.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to connect to event source: %w", err)
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                bodyBytes, readErr := io.ReadAll(resp.Body)
                if closeErr := resp.Body.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        // Log or handle close error, primary error is status code
                        t.logger.Printf("[DEBUG] error closing response body after non-OK status: %v\n", closeErr)
                }</span>
                <span class="cov0" title="0">if resp.StatusCode == http.StatusMethodNotAllowed </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("server does not support GET for SSE (405 Method Not Allowed)")
                }</span>
                <span class="cov0" title="0">errMsg := fmt.Sprintf("failed to connect to event source, status: %s", resp.Status)
                if readErr == nil &amp;&amp; len(bodyBytes) &gt; 0 </span><span class="cov0" title="0">{
                        errMsg = fmt.Sprintf("%s, body: %s", errMsg, string(bodyBytes))
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("%s", errMsg)</span>
        }

        <span class="cov0" title="0">if !strings.Contains(resp.Header.Get("Content-Type"), "text/event-stream") </span><span class="cov0" title="0">{
                if err := resp.Body.Close(); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error closing response body: %w", err)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("server did not return text/event-stream content type")</span>
        }

        <span class="cov0" title="0">es.Connection = resp
        es.isConnected.Store(true)

        // Start reading events
        go es.readEvents(ctx)

        return es, nil</span>
}

// SendRequest sends a request and waits for the response
func (t *StreamableHTTPTransport) SendRequest(ctx context.Context, method string, params interface{}) (interface{}, error) <span class="cov0" title="0">{
        idStr := fmt.Sprintf("%s-%d", t.requestIDPrefix, t.GetNextID()) // Ensure string ID for protocol compatibility

        reqMsg, err := protocol.NewRequest(idStr, method, params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        // Use a unique stream ID for this request to differentiate its SSE stream
        // if the server upgrades the POST to SSE.
        <span class="cov0" title="0">requestStreamID := "request-" + idStr

        responseChan := make(chan *protocol.Response, 1)
        t.mu.Lock()
        t.responseHandlers[idStr] = func(resp *protocol.Response) </span><span class="cov0" title="0">{
                select </span>{
                case responseChan &lt;- resp:<span class="cov0" title="0"></span>
                default:<span class="cov0" title="0">
                        t.logger.Printf("[WARN] SendRequest: responseChan for %s is full or closed, discarding response\n", idStr)</span>
                }
        }
        <span class="cov0" title="0">t.mu.Unlock()

        defer func() </span><span class="cov0" title="0">{
                t.mu.Lock()
                delete(t.responseHandlers, idStr)
                t.mu.Unlock()
                close(responseChan)
        }</span>()

        // Send HTTP request. The context passed here (ctx) is the one that might be cancelled.
        <span class="cov0" title="0">if err := t.sendHTTPRequest(ctx, reqMsg, requestStreamID); err != nil </span><span class="cov0" title="0">{
                // Check if the error was due to context cancellation during the POST operation
                if ctx.Err() != nil </span><span class="cov0" title="0">{
                        t.logger.Printf("[DEBUG] SendRequest's initial POST for request %s failed due to context cancellation: %v. Attempting cancel notification.\n", idStr, ctx.Err())
                        cancelNotifParams := protocol.CancelParams{ID: idStr}
                        // Use a new, short-lived context for the cancellation notification
                        cancelCtx, cancelFunc := context.WithTimeout(context.Background(), 5*time.Second)
                        defer cancelFunc()
                        if notifErr := t.SendNotification(cancelCtx, "$/cancelRequest", cancelNotifParams); notifErr != nil </span><span class="cov0" title="0">{
                                t.logger.Printf("[WARN] SendRequest: failed to send $/cancelRequest notification for %s after POST error: %v\n", idStr, notifErr)
                        }</span>
                }
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to send HTTP request for %s: %w", idStr, err)</span>
        }

        // Wait for the response, or for the original context or a specific wait timeout to be done.
        <span class="cov0" title="0">waitCtx, waitCancel := context.WithTimeout(ctx, t.options.RequestTimeout) // waitCtx inherits cancellation from ctx
        defer waitCancel()                                                        // Cleans up the timer for waitCtx

        select </span>{
        case resp := &lt;-responseChan:<span class="cov0" title="0">
                if resp == nil </span><span class="cov0" title="0">{
                        // This case should ideally not happen if sendHTTPRequest was successful and no context cancelled it
                        // before a response or error was processed by handleMessage/processEventSource.
                        // However, if the channel was closed by the defer without a response, this might occur.
                        return nil, fmt.Errorf("received nil response for request %s, channel may have been closed prematurely", idStr)
                }</span>
                <span class="cov0" title="0">t.logger.Printf("[DEBUG] Received response for request %s\n", idStr)
                if resp.Error != nil </span><span class="cov0" title="0">{
                        return nil, &amp;protocol.ErrorObject{Code: int(resp.Error.Code), Message: resp.Error.Message, Data: resp.Error.Data}
                }</span>
                <span class="cov0" title="0">var result interface{}
                if len(resp.Result) &gt; 0 </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(resp.Result, &amp;result); err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to unmarshal result for request %s: %w", idStr, err)
                        }</span>
                }
                <span class="cov0" title="0">return result, nil</span>

        case &lt;-waitCtx.Done():<span class="cov0" title="0"> // Handles both waitCtx timeout and cancellation from parent ctx
                err := waitCtx.Err()
                t.logger.Printf("[DEBUG] SendRequest: waitCtx done for request %s: %v\n", idStr, err)

                // Attempt to send $/cancelRequest notification
                cancelNotifParams := protocol.CancelParams{ID: idStr}
                cancelAttemptCtx, cancelAttemptDone := context.WithTimeout(context.Background(), 5*time.Second)
                defer cancelAttemptDone()
                if notifErr := t.SendNotification(cancelAttemptCtx, "$/cancelRequest", cancelNotifParams); notifErr != nil </span><span class="cov0" title="0">{
                        t.logger.Printf("[WARN] SendRequest: failed to send $/cancelRequest notification for %s: %v\n", idStr, notifErr)
                }</span>

                // Clean up any dedicated SSE stream for this request
                <span class="cov0" title="0">if esVal, loaded := t.eventSources.LoadAndDelete(requestStreamID); loaded </span><span class="cov0" title="0">{
                        if es, ok := esVal.(*StreamableEventSource); ok </span><span class="cov0" title="0">{
                                t.logger.Printf("[DEBUG] SendRequest: closing event source %s due to context cancellation/timeout\n", requestStreamID)
                                es.Close() // This will also ensure its goroutines (readEvents, processEventSource) terminate
                        }</span>
                }

                <span class="cov0" title="0">if errors.Is(err, context.DeadlineExceeded) &amp;&amp; ctx.Err() == nil </span><span class="cov0" title="0">{
                        // This was a timeout specific to waitCtx, not the parent ctx
                        return nil, fmt.Errorf("request %s timed out after %s: %w", idStr, t.options.RequestTimeout, err)
                }</span> else<span class="cov0" title="0"> if errors.Is(err, context.Canceled) || (ctx.Err() != nil) </span><span class="cov0" title="0">{
                        // This was a cancellation, either from parent ctx or explicitly on waitCtx (though less common)
                        return nil, fmt.Errorf("request %s cancelled: %w", idStr, ctx.Err()) // Prefer parent context error if available
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("request %s failed: %w", idStr, err)</span> // Fallback
        }
}

// SendNotification sends a notification (one-way message)
func (t *StreamableHTTPTransport) SendNotification(ctx context.Context, method string, params interface{}) error <span class="cov0" title="0">{
        notification, err := protocol.NewNotification(method, params)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create notification: %w", err)
        }</span>

        // Send the notification via HTTP POST
        // No need to create a stream for a notification as we don't expect a response
        <span class="cov0" title="0">err = t.sendHTTPRequest(ctx, notification, "")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to send HTTP notification: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Start begins processing messages (blocking)
func (t *StreamableHTTPTransport) Start(ctx context.Context) error <span class="cov0" title="0">{
        if !t.running.CompareAndSwap(false, true) </span><span class="cov0" title="0">{
                return fmt.Errorf("transport already running")
        }</span>

        // We already started a listener connection in Initialize, so now we just wait
        <span class="cov0" title="0">&lt;-ctx.Done()

        return ctx.Err()</span>
}

// Stop gracefully shuts down the transport
func (t *StreamableHTTPTransport) Stop(ctx context.Context) error <span class="cov0" title="0">{
        if !t.running.CompareAndSwap(true, false) </span><span class="cov0" title="0">{
                return nil // Already stopped
        }</span>

        // Close all event sources
        <span class="cov0" title="0">t.eventSources.Range(func(key, value interface{}) bool </span><span class="cov0" title="0">{
                if es, ok := value.(*StreamableEventSource); ok </span><span class="cov0" title="0">{
                        es.Close()
                }</span>
                <span class="cov0" title="0">t.eventSources.Delete(key)
                return true</span>
        })

        <span class="cov0" title="0">return nil</span>
}

// SendBatch sends a batch of JSON-RPC messages
func (t *StreamableHTTPTransport) SendBatch(ctx context.Context, messages []interface{}) error <span class="cov0" title="0">{
        // Send the batch via HTTP POST
        // No stream ID needed since we're not expecting specific stream responses for batches
        return t.sendHTTPRequest(ctx, messages, "")
}</span>

// sendHTTPRequest sends a JSON-RPC message or batch via HTTP POST
func (t *StreamableHTTPTransport) sendHTTPRequest(ctx context.Context, message interface{}, streamID string) error <span class="cov0" title="0">{
        // Marshal the message to JSON
        data, err := json.Marshal(message)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal message: %w", err)
        }</span>

        // Create a new request with the provided context
        <span class="cov0" title="0">req, err := http.NewRequestWithContext(ctx, "POST", t.endpoint, bytes.NewBuffer(data))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create request: %w", err)
        }</span>

        // Set headers
        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Accept", "application/json, text/event-stream")

        // Copy all custom headers
        t.mu.Lock()
        for k, v := range t.headers </span><span class="cov0" title="0">{
                req.Header.Set(k, v)
        }</span>

        // Add session ID if available
        <span class="cov0" title="0">sessionID := t.sessionID
        t.mu.Unlock()

        if sessionID != "" </span><span class="cov0" title="0">{
                t.logger.Printf("[DEBUG] Adding session ID to request: %s\n", sessionID)
                req.Header.Set("MCP-Session-ID", sessionID)
        }</span> else<span class="cov0" title="0"> {
                t.logger.Printf("[DEBUG] No session ID available for request\n")
        }</span>

        // Add stream ID if available, to associate with a specific stream
        // This is mainly for the server to know which GET stream a POST might relate to, if any.
        // For POSTs upgraded to SSE, the client manages this association via requestStreamID.
        <span class="cov0" title="0">if streamID != "" &amp;&amp; !strings.HasPrefix(streamID, "request-") </span><span class="cov0" title="0">{ // Don't send request- specific streamIDs as headers
                req.Header.Set("MCP-Stream-ID", streamID)
        }</span>

        // Send the request with context timeout
        <span class="cov0" title="0">resp, err := t.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to send request: %w", err)
        }</span>

        // sseStreamHandedOff is true if the response body (SSE stream) is passed to an EventSource
        <span class="cov0" title="0">sseStreamHandedOff := false
        defer func() </span><span class="cov0" title="0">{
                if !sseStreamHandedOff &amp;&amp; resp != nil &amp;&amp; resp.Body != nil </span><span class="cov0" title="0">{
                        if err := resp.Body.Close(); err != nil </span><span class="cov0" title="0">{
                                t.logger.Printf("[DEBUG] Error closing response body in sendHTTPRequest defer: %v\n", err)
                        }</span>
                }
        }()

        // Check for HTTP errors
        <span class="cov0" title="0">if resp.StatusCode &gt;= 400 </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body) // Body is closed by defer
                return fmt.Errorf("HTTP error %d: %s", resp.StatusCode, string(body))
        }</span>

        // Extract and store session ID from response headers
        <span class="cov0" title="0">if respSessionID := resp.Header.Get("MCP-Session-ID"); respSessionID != "" </span><span class="cov0" title="0">{
                t.logger.Printf("[DEBUG] Received session ID from server: %s\n", respSessionID)
                t.mu.Lock()
                if t.sessionID == "" || t.sessionID != respSessionID </span><span class="cov0" title="0">{
                        t.sessionID = respSessionID
                        t.logger.Printf("[DEBUG] Updated session ID for future requests: %s\n", respSessionID)
                }</span>
                <span class="cov0" title="0">t.mu.Unlock()</span>
        } else<span class="cov0" title="0"> {
                t.logger.Printf("[DEBUG] No session ID received from server in response headers\n")
                // fmt.Printf("[DEBUG] Response headers: %+v\n", resp.Header) // Can be noisy
        }</span>

        // Handle the response based on content type
        <span class="cov0" title="0">contentType := resp.Header.Get("Content-Type")

        if strings.Contains(contentType, "text/event-stream") </span><span class="cov0" title="0">{
                t.logger.Printf("[DEBUG] Received SSE response (Content-Type: %s) for streamID: %s\n", contentType, streamID)
                // This POST request is being upgraded to an SSE stream for its response.
                // The streamID here should be the request-specific one (e.g., "request-http-123")
                if strings.HasPrefix(streamID, "request-") </span><span class="cov0" title="0">{
                        // Create a new event source using the live HTTP response body (which is the SSE stream)
                        // The context (ctx) passed to processEventSource must be the original request's context.
                        lastEventID := resp.Header.Get("Last-Event-ID") // Though unlikely for a fresh POST-SSE stream
                        es := &amp;StreamableEventSource{
                                URL:         t.endpoint, // For potential future reconnections, though this ES is tied to this specific resp
                                Headers:     t.headers,  // Headers for potential reconnections
                                Client:      t.client,   // Client for potential reconnections
                                Connection:  resp,       // The live http.Response with the SSE stream
                                MessageChan: make(chan []byte, 100),
                                ErrorChan:   make(chan error, 10),
                                CloseChan:   make(chan struct{}),
                                StreamID:    streamID,
                                LastEventID: lastEventID,
                        }
                        es.isConnected.Store(true)         // Mark as connected since we have the live response
                        t.eventSources.Store(streamID, es) // Store it so SendRequest can find it

                        // Start reading events from this stream using the response body directly.
                        // This goroutine is tied to the lifecycle of the original request's context (ctx).
                        go es.readEvents(ctx)     // readEvents will handle closing resp.Body when done or on error
                        sseStreamHandedOff = true // The resp.Body is now managed by es.readEvents

                        // Start processing messages from this new event source.
                        // This goroutine is also tied to the lifecycle of the original request's context (ctx).
                        go t.processEventSource(ctx, es)
                        t.logger.Printf("[DEBUG] Handed off POST response's SSE stream to new EventSource for streamID: %s\n", streamID)
                }</span> else<span class="cov0" title="0"> {
                        // This is an SSE stream not directly tied to a SendRequest call (e.g., from SendBatch or other internal POSTs)
                        // We don't expect SSE responses for simple notifications/batches normally, but if it happens, log and close.
                        t.logger.Printf("[WARN] Received unexpected SSE stream for non-request streamID: %s. Closing.\n", streamID)
                        // Body will be closed by the main defer as sseStreamHandedOff is false.
                }</span>
        } else<span class="cov0" title="0"> if strings.Contains(contentType, "application/json") </span><span class="cov0" title="0">{
                t.logger.Printf("[DEBUG] Received JSON response (Content-Type: %s)\n", contentType)
                body, err := io.ReadAll(resp.Body) // Body is closed by defer
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to read JSON response body: %w", err)
                }</span>
                <span class="cov0" title="0">if len(body) &gt; 0 </span><span class="cov0" title="0">{
                        if err := t.handleMessage(context.Background(), body); err != nil </span><span class="cov0" title="0">{ // Use background context as we have the full response
                                return fmt.Errorf("failed to process JSON message: %w", err)
                        }</span>
                }
        } else<span class="cov0" title="0"> if resp.StatusCode == http.StatusAccepted || resp.StatusCode == http.StatusNoContent </span><span class="cov0" title="0">{ // HTTP 202 or 204
                t.logger.Printf("[DEBUG] Received HTTP %d %s response. No content to process.\n", resp.StatusCode, http.StatusText(resp.StatusCode))
                // No body to process, and it will be closed by the main defer.
        }</span> else<span class="cov0" title="0"> {
                t.logger.Printf("[DEBUG] Unexpected Content-Type in response: '%s' or unhandled status code: %d\n", contentType, resp.StatusCode)
                body, err := io.ReadAll(resp.Body) // Body is closed by defer
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to read response body with unknown content type: %w", err)
                }</span>
                <span class="cov0" title="0">if len(body) &gt; 0 </span><span class="cov0" title="0">{
                        t.logger.Printf("[DEBUG] Response body with unknown content type: %s\n", string(body))
                        // Potentially try to handle as JSON if it's a server error without proper Content-Type
                        if resp.StatusCode &gt;= 400 </span><span class="cov0" title="0">{
                                if err := t.handleMessage(context.Background(), body); err != nil </span><span class="cov0" title="0">{
                                        t.logger.Printf("[DEBUG] Tried to handle unknown content type as JSON error, but failed: %v\n", err)
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// processEventSource processes messages from an event source
func (t *StreamableHTTPTransport) processEventSource(ctx context.Context, es *StreamableEventSource) <span class="cov0" title="0">{
        t.logger.Printf("processEventSource: Starting for stream %s", es.StreamID)
        var eventReadingWG sync.WaitGroup

        defer func() </span><span class="cov0" title="0">{
                t.logger.Printf("processEventSource: Exiting for stream %s. Waiting for event reading goroutine to finish...", es.StreamID)
                eventReadingWG.Wait() // Wait for the event reading goroutine to finish before fully exiting
                t.logger.Printf("processEventSource: Event reading goroutine finished for stream %s.", es.StreamID)
                if es != nil </span><span class="cov0" title="0">{
                        es.Close() // Ensure event source's underlying connection (Body) is closed
                        t.logger.Printf("processEventSource: Closed event source for stream %s in defer.", es.StreamID)
                }</span>
                // If this event source was associated with a request, remove it from active event sources
                <span class="cov0" title="0">if strings.HasPrefix(es.StreamID, "request-") </span><span class="cov0" title="0">{
                        t.eventSources.Delete(es.StreamID)
                        t.logger.Printf("processEventSource: Deleted event source %s from active map.", es.StreamID)
                }</span>
        }()

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        t.logger.Printf("processEventSource: Parent context done for stream %s: %v", es.StreamID, ctx.Err())
                        return</span>
                default:<span class="cov0" title="0"></span>
                }

                // Create a new context for this connection attempt, derived from the parent context
                // This allows us to cancel this specific connection attempt if needed (e.g., for retry)
                <span class="cov0" title="0">esConnectionCtx, esConnectionCancel := context.WithCancel(ctx)

                eventReadingWG.Add(1)
                go func() </span><span class="cov0" title="0">{
                        defer eventReadingWG.Done()
                        defer esConnectionCancel() // Crucially, cancel the connection-specific context when this goroutine exits
                        t.logger.Printf("processEventSource: Starting event reading goroutine for stream %s", es.StreamID)
                        es.readEvents(esConnectionCtx) // Pass the connection-specific context
                        t.logger.Printf("processEventSource: Event reading goroutine finished for stream %s", es.StreamID)
                }</span>()

                <span class="cov0" title="0">keepProcessingThisSource := true
                for keepProcessingThisSource </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0"> // Parent context cancelled
                                t.logger.Printf("processEventSource: Parent context done during message processing for stream %s: %v", es.StreamID, ctx.Err())
                                esConnectionCancel() // Signal the event reading goroutine to stop
                                return</span>               // Exit processEventSource

                        case &lt;-esConnectionCtx.Done():<span class="cov0" title="0"> // Current connection attempt's context cancelled (e.g. readEvents finished or error)
                                t.logger.Printf("processEventSource: Connection context done for stream %s: %v. Will attempt reconnect if appropriate.", es.StreamID, esConnectionCtx.Err())
                                keepProcessingThisSource = false</span> // Break inner loop to retry connection

                        case msg, ok := &lt;-es.MessageChan:<span class="cov0" title="0">
                                if !ok </span><span class="cov0" title="0">{
                                        t.logger.Printf("processEventSource: MessageChan closed for stream %s. Connection likely lost.", es.StreamID)
                                        esConnectionCancel()             // Ensure event reading goroutine is stopped
                                        keepProcessingThisSource = false // Break inner loop to retry connection
                                        continue</span>
                                }
                                <span class="cov0" title="0">t.logger.Printf("processEventSource: Received message on stream %s: %s", es.StreamID, string(msg))
                                if err := t.handleMessage(ctx, msg); err != nil </span><span class="cov0" title="0">{
                                        t.logger.Printf("Error handling message on stream %s: %v", es.StreamID, err)
                                        // Depending on error type, might decide to stop or continue
                                }</span>

                        case err, ok := &lt;-es.ErrorChan:<span class="cov0" title="0">
                                if !ok </span><span class="cov0" title="0">{
                                        t.logger.Printf("processEventSource: ErrorChan closed for stream %s.", es.StreamID)
                                        esConnectionCancel()             // Ensure event reading goroutine is stopped
                                        keepProcessingThisSource = false // Break inner loop to retry connection
                                        continue</span>
                                }
                                <span class="cov0" title="0">t.logger.Printf("processEventSource: Received error on stream %s: %v. Will attempt reconnect.", es.StreamID, err)
                                esConnectionCancel()             // Ensure event reading goroutine is stopped
                                keepProcessingThisSource = false</span> // Break inner loop to retry connection
                        }
                }

                // Before retrying, wait for the current event reading goroutine to complete fully.
                <span class="cov0" title="0">t.logger.Printf("processEventSource: Waiting for active event reader to finish before potential retry for stream %s...", es.StreamID)
                eventReadingWG.Wait()
                t.logger.Printf("processEventSource: Active event reader finished for stream %s.", es.StreamID)

                // If the parent context is done, don't attempt to reconnect.
                if ctx.Err() != nil </span><span class="cov0" title="0">{
                        t.logger.Printf("processEventSource: Parent context done, not retrying connection for stream %s.", es.StreamID)
                        return
                }</span>

                // Reconnect logic
                <span class="cov0" title="0">t.logger.Printf("processEventSource: Attempting to reconnect stream %s with LastEventID: %s", es.StreamID, es.LastEventID)
                var err error
                var newEs *StreamableEventSource // Placeholder for re-establishing or reusing 'es'
                // In a real scenario, you'd try to create a new connection for 'es'
                // For simplicity in this example, we'll just simulate a delay and potentially re-use 'es' if the design allows.
                // If 'es' internally handles reconnection, then this part changes.

                // This is where createEventSource or a similar mechanism would be called again.
                // For the main listener, it should try indefinitely. For request streams, it might depend on request context.
                if es.StreamID == "listener" </span><span class="cov0" title="0">{
                        t.logger.Printf("processEventSource: Reconnecting listener stream %s", es.StreamID)
                        newEs, err = t.createEventSource(es.StreamID, es.LastEventID, ctx) // Pass parent ctx
                }</span> else<span class="cov0" title="0"> if strings.HasPrefix(es.StreamID, "request-") </span><span class="cov0" title="0">{
                        // For request-specific streams, their lifecycle is tied to the request's context.
                        // If the request context (which should be `ctx` here) is done, no need to reconnect.
                        if ctx.Err() != nil </span><span class="cov0" title="0">{
                                t.logger.Printf("processEventSource: Request context done for stream %s, not reconnecting.", es.StreamID)
                                return
                        }</span>
                        <span class="cov0" title="0">t.logger.Printf("processEventSource: Reconnecting request stream %s", es.StreamID)
                        newEs, err = t.createEventSource(es.StreamID, es.LastEventID, ctx)</span> // Pass parent (request) ctx
                } else<span class="cov0" title="0"> {
                        t.logger.Printf("processEventSource: Unknown stream type %s, not attempting reconnect.", es.StreamID)
                        return
                }</span>

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        t.logger.Printf("processEventSource: Failed to recreate event source for stream %s: %v. Retrying after delay.", es.StreamID, err)
                        select </span>{
                        case &lt;-time.After(5 * time.Second):<span class="cov0" title="0"></span> // Backoff before retrying
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                t.logger.Printf("processEventSource: Parent context done during reconnect backoff for stream %s.", es.StreamID)
                                return</span>
                        }
                        <span class="cov0" title="0">continue</span> // Retry the outer loop (which will attempt to create and process a new connection)
                }
                // Selectively update fields instead of copying the entire struct with mutex
                <span class="cov0" title="0">es.URL = newEs.URL
                es.Headers = newEs.Headers
                es.Client = newEs.Client
                es.Connection = newEs.Connection
                es.LastEventID = newEs.LastEventID
                es.StreamID = newEs.StreamID
                // Note: we don't copy mutex (es.mu) or channels which should be preserved
                t.logger.Printf("processEventSource: Successfully re-established event source for stream %s.", es.StreamID)</span>
                // Loop continues, a new esConnectionCtx will be created, and readEvents will be launched for the new 'es'
        }
}

// handleBatchMessage processes a batch of JSON-RPC messages
func (t *StreamableHTTPTransport) handleBatchMessage(ctx context.Context, data []byte) error <span class="cov0" title="0">{
        // Check what kind of batch this is (could be a batch of requests, responses, or notifications)
        var rawMessages []json.RawMessage
        if err := json.Unmarshal(data, &amp;rawMessages); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to unmarshal batch: %w", err)
        }</span>

        // Process each message in the batch
        <span class="cov0" title="0">var responsesBatch []interface{}

        for _, rawMsg := range rawMessages </span><span class="cov0" title="0">{
                if protocol.IsRequest(rawMsg) </span><span class="cov0" title="0">{
                        // Parse as a request
                        var req protocol.Request
                        if err := json.Unmarshal(rawMsg, &amp;req); err != nil </span><span class="cov0" title="0">{
                                continue</span> // Skip invalid messages in batch
                        }

                        // Handle the request
                        <span class="cov0" title="0">resp, err := t.HandleRequest(ctx, &amp;req)
                        if err != nil </span><span class="cov0" title="0">{
                                // Create error response
                                errResp, _ := protocol.NewErrorResponse(req.ID, protocol.InternalError, err.Error(), nil)
                                responsesBatch = append(responsesBatch, errResp)
                        }</span> else<span class="cov0" title="0"> if resp != nil </span><span class="cov0" title="0">{
                                // Add to batch of responses
                                responsesBatch = append(responsesBatch, resp)
                        }</span>
                } else<span class="cov0" title="0"> if protocol.IsResponse(rawMsg) </span><span class="cov0" title="0">{
                        // Parse as a response
                        var resp protocol.Response
                        if err := json.Unmarshal(rawMsg, &amp;resp); err != nil </span><span class="cov0" title="0">{
                                continue</span> // Skip invalid messages
                        }

                        // Handle the response
                        <span class="cov0" title="0">t.HandleResponse(&amp;resp)</span>
                } else<span class="cov0" title="0"> if protocol.IsNotification(rawMsg) </span><span class="cov0" title="0">{
                        // Parse as a notification
                        var notif protocol.Notification
                        if err := json.Unmarshal(rawMsg, &amp;notif); err != nil </span><span class="cov0" title="0">{
                                continue</span> // Skip invalid messages
                        }

                        // Handle the notification
                        <span class="cov0" title="0">_ = t.HandleNotification(ctx, &amp;notif)</span> // Ignore errors for notifications in batch
                }
        }

        // Send batch of responses if we have any
        <span class="cov0" title="0">if len(responsesBatch) &gt; 0 </span><span class="cov0" title="0">{
                err := t.sendHTTPRequest(ctx, responsesBatch, "")
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to send batch responses: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// handleMessage processes an incoming JSON-RPC message, which could be a single message or batch
func (t *StreamableHTTPTransport) handleMessage(ctx context.Context, data []byte) error <span class="cov0" title="0">{
        // Check for empty or whitespace-only messages
        trimmed := bytes.TrimSpace(data)
        if len(trimmed) == 0 </span><span class="cov0" title="0">{
                t.logger.Printf("[DEBUG] Ignoring empty message\n")
                return nil // Just ignore empty messages
        }</span>

        // Check if it's an empty JSON object {}
        <span class="cov0" title="0">if string(trimmed) == "{}" </span><span class="cov0" title="0">{
                t.logger.Printf("[DEBUG] Ignoring empty JSON object message\n")
                // This is likely a heartbeat or initialization message, just ignore it
                return nil
        }</span>

        // First, try to check if it's a connection event or other special SSE event
        <span class="cov0" title="0">var connectionEvent struct {
                ConnectionID string `json:"connectionId"`
        }

        if err := json.Unmarshal(trimmed, &amp;connectionEvent); err == nil &amp;&amp; connectionEvent.ConnectionID != "" </span><span class="cov0" title="0">{
                t.logger.Printf("[DEBUG] Received connection event with ID: %s\n", connectionEvent.ConnectionID)
                // This is a connection event from the server, not a JSON-RPC message
                return nil
        }</span>

        // Check if this is a batch (JSON array)
        <span class="cov0" title="0">if len(data) &gt; 0 &amp;&amp; data[0] == '[' </span><span class="cov0" title="0">{
                t.logger.Printf("[DEBUG] Processing batch message\n")
                return t.handleBatchMessage(ctx, data)
        }</span>

        // Process single message
        // Determine message type and handle accordingly
        <span class="cov0" title="0">if protocol.IsRequest(data) </span><span class="cov0" title="0">{
                t.logger.Printf("[DEBUG] Processing request message\n")
                // Parse as a request
                var req protocol.Request
                if err := json.Unmarshal(data, &amp;req); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to unmarshal request: %w", err)
                }</span>

                // Handle the request using the provided context
                <span class="cov0" title="0">resp, err := t.HandleRequest(ctx, &amp;req)
                if err != nil </span><span class="cov0" title="0">{
                        t.logger.Printf("[ERROR] Failed to handle request %s: %v\n", req.Method, err)
                        return fmt.Errorf("failed to handle request: %w", err)
                }</span>

                // Send the response if not nil
                <span class="cov0" title="0">if resp != nil </span><span class="cov0" title="0">{
                        // Use a short timeout context for the response
                        respCtx, cancel := context.WithTimeout(ctx, 10*time.Second)
                        defer cancel()

                        err = t.sendHTTPRequest(respCtx, resp, "")
                        if err != nil </span><span class="cov0" title="0">{
                                t.logger.Printf("[ERROR] Failed to send response for request %s: %v\n", req.Method, err)
                                return fmt.Errorf("failed to send response: %w", err)
                        }</span>
                }

                <span class="cov0" title="0">return nil</span>
        } else<span class="cov0" title="0"> if protocol.IsResponse(data) </span><span class="cov0" title="0">{
                t.logger.Printf("[DEBUG] Processing response message\n")
                // Parse as a response
                var resp protocol.Response
                if err := json.Unmarshal(data, &amp;resp); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to unmarshal response: %w", err)
                }</span>

                // Handle the response
                <span class="cov0" title="0">t.HandleResponse(&amp;resp)

                return nil</span>
        } else<span class="cov0" title="0"> if protocol.IsNotification(data) </span><span class="cov0" title="0">{
                t.logger.Printf("[DEBUG] Processing notification message\n")
                // Parse as a notification
                var notif protocol.Notification
                if err := json.Unmarshal(data, &amp;notif); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to unmarshal notification: %w", err)
                }</span>

                // Handle the notification with the provided context
                <span class="cov0" title="0">err := t.HandleNotification(ctx, &amp;notif)
                if err != nil </span><span class="cov0" title="0">{
                        t.logger.Printf("[ERROR] Failed to handle notification %s: %v\n", notif.Method, err)
                        return fmt.Errorf("failed to handle notification: %w", err)
                }</span>

                <span class="cov0" title="0">return nil</span>
        }

        // Log a sample of the message for debugging
        <span class="cov0" title="0">maxLen := 100
        sampleData := string(data)
        if len(sampleData) &gt; maxLen </span><span class="cov0" title="0">{
                sampleData = sampleData[:maxLen] + "..."
        }</span>

        // Debug log - this will help diagnose issues
        <span class="cov0" title="0">t.logger.Printf("[DEBUG] Received unrecognized message: %s\n", sampleData)

        // Check if it's at least valid JSON
        var anyJSON interface{}
        jsonErr := json.Unmarshal(data, &amp;anyJSON)

        if jsonErr != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid JSON message: %w, data: %s", jsonErr, sampleData)
        }</span> else<span class="cov0" title="0"> {
                // It's valid JSON but not a recognized JSON-RPC message type
                // Since we're already handling empty objects above, this must be another format
                t.logger.Printf("[DEBUG] Valid JSON but not recognized as JSON-RPC message: %s\n", sampleData)
                return nil // Don't treat as error, just ignore unrecognized message formats
        }</span>
}

// Connect establishes a connection to the SSE endpoint
func (es *StreamableEventSource) Connect() error <span class="cov0" title="0">{
        es.mu.Lock()
        defer es.mu.Unlock()

        if es.isConnected.Load() </span><span class="cov0" title="0">{
                return nil // Already connected
        }</span>

        // Create request
        <span class="cov0" title="0">req, err := http.NewRequest("GET", es.URL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create request: %w", err)
        }</span>

        // Set headers
        <span class="cov0" title="0">req.Header.Set("Accept", "text/event-stream")
        for k, v := range es.Headers </span><span class="cov0" title="0">{
                req.Header.Set(k, v)
        }</span>

        // Add Last-Event-ID if resuming
        <span class="cov0" title="0">if es.LastEventID != "" </span><span class="cov0" title="0">{
                req.Header.Set("Last-Event-ID", es.LastEventID)
        }</span>

        // Send request
        <span class="cov0" title="0">resp, err := es.Client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to connect: %w", err)
        }</span>

        // Check response
        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                if err := resp.Body.Close(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error closing response body: %w", err)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to connect: HTTP %d", resp.StatusCode)</span>
        }

        <span class="cov0" title="0">es.Connection = resp
        es.isConnected.Store(true)

        // Start reading events
        go es.readEvents(context.Background())

        return nil</span>
}

// Close terminates the SSE connection
func (es *StreamableEventSource) Close() <span class="cov0" title="0">{
        es.mu.Lock()
        defer es.mu.Unlock()

        if !es.isConnected.Load() </span><span class="cov0" title="0">{
                fmt.Printf("[DEBUG] EventSource %s already closed\n", es.StreamID)
                return // Already closed
        }</span>

        // Set the flag first to prevent concurrent access issues
        <span class="cov0" title="0">es.isConnected.Store(false)

        // Safely close the connection body if it exists
        if es.Connection != nil &amp;&amp; es.Connection.Body != nil </span><span class="cov0" title="0">{
                if err := es.Connection.Body.Close(); err != nil </span><span class="cov0" title="0">{
                        // Just log the error as we're in a cleanup path
                        fmt.Printf("[DEBUG] Error closing connection body for %s: %v\n", es.StreamID, err)
                }</span>
                // Explicitly set to nil to prevent accidental reuse
                <span class="cov0" title="0">es.Connection.Body = nil
                es.Connection = nil</span>
        } else<span class="cov0" title="0"> {
                fmt.Printf("[DEBUG] EventSource %s has nil connection or body\n", es.StreamID)
        }</span>

        // Close the channel after handling the connection to prevent race conditions
        <span class="cov0" title="0">select </span>{
        case &lt;-es.CloseChan:<span class="cov0" title="0">
                // Channel already closed
                fmt.Printf("[DEBUG] EventSource %s close channel already closed\n", es.StreamID)</span>
        default:<span class="cov0" title="0">
                fmt.Printf("[DEBUG] Closing EventSource %s channel\n", es.StreamID)
                close(es.CloseChan)</span>
        }

        <span class="cov0" title="0">fmt.Printf("[DEBUG] EventSource %s successfully closed\n", es.StreamID)</span>
}

// readEvents processes the SSE stream
func (es *StreamableEventSource) readEvents(ctx context.Context) <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                // Additional safety check in case of panics
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        fmt.Printf("[DEBUG] Recovered from panic in readEvents for %s: %v\n", es.StreamID, r)
                }</span>

                // Ensure connection is marked as disconnected
                <span class="cov0" title="0">wasConnected := es.isConnected.Swap(false)

                // Safely close the connection if we were previously connected
                if wasConnected </span><span class="cov0" title="0">{
                        es.mu.Lock()
                        if es.Connection != nil &amp;&amp; es.Connection.Body != nil </span><span class="cov0" title="0">{
                                if err := es.Connection.Body.Close(); err != nil </span><span class="cov0" title="0">{
                                        fmt.Printf("[DEBUG] Error closing connection body in readEvents for %s: %v\n", es.StreamID, err)
                                }</span>
                                // Clear the body reference to avoid accidental reuse
                                <span class="cov0" title="0">es.Connection.Body = nil</span>
                        }
                        <span class="cov0" title="0">es.mu.Unlock()

                        // Notify of disconnection only if we were previously connected and channels are still valid
                        select </span>{
                        case &lt;-es.CloseChan:<span class="cov0" title="0">
                                fmt.Printf("[DEBUG] CloseChan already closed for %s\n", es.StreamID)</span>
                        default:<span class="cov0" title="0">
                                select </span>{
                                case es.ErrorChan &lt;- fmt.Errorf("connection closed"):<span class="cov0" title="0">
                                        fmt.Printf("[DEBUG] Sent disconnection notification for %s\n", es.StreamID)</span>
                                default:<span class="cov0" title="0">
                                        fmt.Printf("[DEBUG] ErrorChan is full or closed for %s, can't send error\n", es.StreamID)</span>
                                }
                        }

                        <span class="cov0" title="0">fmt.Printf("[DEBUG] SSE connection closed for stream %s\n", es.StreamID)</span>
                }
        }()

        // Safety check before starting to read
        <span class="cov0" title="0">es.mu.Lock()
        if es.Connection == nil </span><span class="cov0" title="0">{
                fmt.Printf("[DEBUG] Cannot read from nil connection for stream %s\n", es.StreamID)
                es.mu.Unlock()
                return
        }</span>

        <span class="cov0" title="0">if es.Connection.Body == nil </span><span class="cov0" title="0">{
                fmt.Printf("[DEBUG] Cannot read from nil connection body for stream %s\n", es.StreamID)
                es.mu.Unlock()
                return
        }</span>

        // Use a buffered reader for efficiency
        <span class="cov0" title="0">reader := bufio.NewReaderSize(es.Connection.Body, 4096) // 4KB buffer, larger than default
        es.mu.Unlock()

        eventData := ""
        eventID := ""
        eventType := ""

        // Read events line by line
        for </span><span class="cov0" title="0">{
                // Check if connection is still active before attempting to read
                if !es.isConnected.Load() </span><span class="cov0" title="0">{
                        fmt.Printf("[DEBUG] Connection marked as closed, stopping read loop for stream %s\n", es.StreamID)
                        return
                }</span>

                // Use a shorter read timeout to detect stalled connections
                <span class="cov0" title="0">line, err := readLineWithTimeout(reader, 60*time.Second)
                if err != nil </span><span class="cov0" title="0">{
                        connectionError := ""
                        if err == io.EOF </span><span class="cov0" title="0">{
                                connectionError = "EOF"
                        }</span> else<span class="cov0" title="0"> if strings.Contains(err.Error(), "timeout") </span><span class="cov0" title="0">{
                                connectionError = "read timeout"
                        }</span> else<span class="cov0" title="0"> if strings.Contains(err.Error(), "connection reset") </span><span class="cov0" title="0">{
                                connectionError = "connection reset by peer"
                        }</span> else<span class="cov0" title="0"> if strings.Contains(err.Error(), "closed network") </span><span class="cov0" title="0">{
                                connectionError = "closed network connection"
                        }</span> else<span class="cov0" title="0"> {
                                connectionError = err.Error()
                        }</span>

                        <span class="cov0" title="0">fmt.Printf("[DEBUG] SSE read error for %s: %s\n", es.StreamID, connectionError)

                        // Only send error to channel if connection was active
                        if es.isConnected.Load() </span><span class="cov0" title="0">{
                                select </span>{
                                case &lt;-es.CloseChan:<span class="cov0" title="0"></span>
                                        // Already closed
                                default:<span class="cov0" title="0">
                                        select </span>{
                                        case es.ErrorChan &lt;- err:<span class="cov0" title="0">
                                                fmt.Printf("[DEBUG] Sent read error for %s\n", es.StreamID)</span>
                                        default:<span class="cov0" title="0">
                                                fmt.Printf("[DEBUG] Cannot send error for %s (channel full or closed)\n", es.StreamID)</span>
                                        }
                                }
                        }
                        <span class="cov0" title="0">return</span>
                }

                // Trim the trailing newline
                <span class="cov0" title="0">line = strings.TrimSuffix(line, "\n")
                line = strings.TrimSuffix(line, "\r")

                // Skip empty lines at the beginning
                if line == "" &amp;&amp; eventData == "" &amp;&amp; eventID == "" &amp;&amp; eventType == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Skip comment lines (used as heartbeats)
                <span class="cov0" title="0">if strings.HasPrefix(line, ":") </span><span class="cov0" title="0">{
                        fmt.Printf("[DEBUG] Received SSE heartbeat ping for stream %s: %s\n", es.StreamID, line)
                        continue</span>
                }

                <span class="cov0" title="0">if line == "" </span><span class="cov0" title="0">{
                        // End of event, process it if we have data
                        if eventData != "" </span><span class="cov0" title="0">{
                                // If we have an ID, update the last event ID
                                if eventID != "" </span><span class="cov0" title="0">{
                                        es.LastEventID = eventID
                                        fmt.Printf("[DEBUG] Updated LastEventID to %s for stream %s\n", eventID, es.StreamID)
                                }</span>

                                // Check for specific event types
                                <span class="cov0" title="0">if eventType == "close" </span><span class="cov0" title="0">{
                                        // Server signaled to close the connection
                                        fmt.Printf("[DEBUG] Received close event for stream %s\n", es.StreamID)
                                        es.Close()
                                        return
                                }</span>

                                // Check if this is a connection event
                                <span class="cov0" title="0">if eventType == "connected" || eventType == "ready" </span><span class="cov0" title="0">{
                                        fmt.Printf("[DEBUG] Received connection event for stream %s: %s\n", es.StreamID, eventData)

                                        // Try to parse the connection event
                                        var connectionEvent struct {
                                                ConnectionID string `json:"connectionId"`
                                        }

                                        if err := json.Unmarshal([]byte(eventData), &amp;connectionEvent); err == nil &amp;&amp; connectionEvent.ConnectionID != "" </span><span class="cov0" title="0">{
                                                fmt.Printf("[DEBUG] Parsed connection ID: %s for stream %s\n", connectionEvent.ConnectionID, es.StreamID)
                                        }</span>
                                }

                                // Send the event data to the message channel if still connected
                                <span class="cov0" title="0">if es.isConnected.Load() </span><span class="cov0" title="0">{
                                        select </span>{
                                        case es.MessageChan &lt;- []byte(eventData):<span class="cov0" title="0">
                                                fmt.Printf("[DEBUG] Dispatched event data for stream %s (type: %s)\n", es.StreamID, eventType)</span>
                                        default:<span class="cov0" title="0">
                                                fmt.Printf("[DEBUG] Failed to dispatch event data for stream %s (channel full)\n", es.StreamID)</span>
                                        }
                                }

                                // Reset for next event
                                <span class="cov0" title="0">eventData = ""
                                eventID = ""
                                eventType = ""</span>
                        }
                        <span class="cov0" title="0">continue</span>
                }

                // Process the line
                <span class="cov0" title="0">if strings.HasPrefix(line, "data:") </span><span class="cov0" title="0">{
                        data := strings.TrimPrefix(line, "data:")
                        data = strings.TrimSpace(data)

                        if eventData == "" </span><span class="cov0" title="0">{
                                eventData = data
                        }</span> else<span class="cov0" title="0"> {
                                eventData += "\n" + data
                        }</span>
                } else<span class="cov0" title="0"> if strings.HasPrefix(line, "id:") </span><span class="cov0" title="0">{
                        eventID = strings.TrimPrefix(line, "id:")
                        eventID = strings.TrimSpace(eventID)
                }</span> else<span class="cov0" title="0"> if strings.HasPrefix(line, "event:") </span><span class="cov0" title="0">{
                        eventType = strings.TrimPrefix(line, "event:")
                        eventType = strings.TrimSpace(eventType)
                }</span> else<span class="cov0" title="0"> if strings.HasPrefix(line, "retry:") </span><span class="cov0" title="0">{
                        retryStr := strings.TrimPrefix(line, "retry:")
                        retryStr = strings.TrimSpace(retryStr)

                        // Try to parse retry time if provided
                        if retry, err := strconv.Atoi(retryStr); err == nil </span><span class="cov0" title="0">{
                                fmt.Printf("[DEBUG] SSE retry interval set to %dms for stream %s\n", retry, es.StreamID)
                        }</span>
                } else<span class="cov0" title="0"> {
                        // Unknown line type
                        fmt.Printf("[DEBUG] Unknown SSE line format for stream %s: %s\n", es.StreamID, line)
                }</span>
        }
}

// Helper function to read a line with timeout
func readLineWithTimeout(r *bufio.Reader, timeout time.Duration) (string, error) <span class="cov0" title="0">{
        type readResult struct {
                line string
                err  error
        }

        ch := make(chan readResult, 1)

        go func() </span><span class="cov0" title="0">{
                line, err := r.ReadString('\n')
                ch &lt;- readResult{line, err}
        }</span>()

        <span class="cov0" title="0">select </span>{
        case result := &lt;-ch:<span class="cov0" title="0">
                return result.line, result.err</span>
        case &lt;-time.After(timeout):<span class="cov0" title="0">
                return "", fmt.Errorf("timeout waiting for line")</span>
        }
}

// Send transmits a message over the transport.
// For StreamableHTTPTransport, this is not fully applicable since
// it operates in a request/response model. This is here to satisfy
// the Transport interface.
func (t *StreamableHTTPTransport) Send(data []byte) error <span class="cov0" title="0">{
        return fmt.Errorf("Send method not applicable for StreamableHTTPTransport")
}</span>

// SetErrorHandler sets the handler for transport errors.
func (t *StreamableHTTPTransport) SetErrorHandler(handler ErrorHandler) {<span class="cov0" title="0">
        // This is a placeholder implementation
}</span>

// SetReceiveHandler sets the handler for received messages.
func (t *StreamableHTTPTransport) SetReceiveHandler(handler ReceiveHandler) {<span class="cov0" title="0">
        // This is a placeholder implementation
}</span>

// RegisterProgressHandler registers a handler for progress notifications
// with the given request ID
func (t *StreamableHTTPTransport) RegisterProgressHandler(id interface{}, handler ProgressHandler) <span class="cov0" title="0">{
        idStr := fmt.Sprintf("%v", id)

        t.mu.Lock()
        defer t.mu.Unlock()

        // Initialize the progress handlers map if needed
        if t.progressHandlers == nil </span><span class="cov0" title="0">{
                t.progressHandlers = make(map[string]ProgressHandler)
        }</span>

        <span class="cov0" title="0">t.progressHandlers[idStr] = handler</span>
}

// GetSessionID returns the current session ID
func (t *StreamableHTTPTransport) GetSessionID() string <span class="cov0" title="0">{
        t.mu.Lock()
        defer t.mu.Unlock()
        return t.sessionID
}</span>

// SetResponseHandler sets a custom handler for a specific response ID
func (t *StreamableHTTPTransport) SetResponseHandler(id string, handler func(*protocol.Response)) <span class="cov0" title="0">{
        // Create a channel for the response
        responseChan := make(chan *protocol.Response, 1)

        // Add the channel to the pending requests
        t.BaseTransport.Lock()
        t.BaseTransport.pendingRequests[id] = responseChan
        t.BaseTransport.Unlock()

        // Start a goroutine to handle the response
        go func() </span><span class="cov0" title="0">{
                resp, ok := &lt;-responseChan
                if ok &amp;&amp; resp != nil </span><span class="cov0" title="0">{
                        handler(resp)
                }</span>
        }()
}

// RemoveResponseHandler removes a custom response handler
func (t *StreamableHTTPTransport) RemoveResponseHandler(id string) <span class="cov0" title="0">{
        t.BaseTransport.Lock()
        delete(t.BaseTransport.pendingRequests, id)
        t.BaseTransport.Unlock()
}</span>
</pre>

		<pre class="file" id="file3" style="display: none">// Package transport provides various transport mechanisms for MCP communication.
package transport

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "log"
        "os"
        "runtime/debug"
        "sync"
        "time"

        "github.com/ajitpratap0/mcp-sdk-go/pkg/protocol"
)

// ProgressHandler handles progress notifications for streaming operations
type ProgressHandler func(params interface{}) error

// Transport defines the interface for MCP transport mechanisms.
// Transports are responsible for sending and receiving messages between
// MCP clients and servers.
type Transport interface {
        // Initialize prepares the transport for use.
        Initialize(ctx context.Context) error

        // SendRequest sends a request and returns the response
        SendRequest(ctx context.Context, method string, params interface{}) (interface{}, error)

        // SendNotification sends a notification (one-way message)
        SendNotification(ctx context.Context, method string, params interface{}) error

        // RegisterRequestHandler registers a handler for incoming requests
        RegisterRequestHandler(method string, handler RequestHandler)

        // RegisterNotificationHandler registers a handler for incoming notifications
        RegisterNotificationHandler(method string, handler NotificationHandler)

        // RegisterProgressHandler registers a handler for progress events
        RegisterProgressHandler(id interface{}, handler ProgressHandler)

        // UnregisterProgressHandler removes a progress handler
        UnregisterProgressHandler(id interface{})

        // GenerateID generates a unique ID for requests
        GenerateID() string

        // Start begins reading messages and processing them.
        // This method blocks until the context is canceled or an error occurs.
        Start(ctx context.Context) error

        // Stop halts the transport and cleans up resources.
        Stop(ctx context.Context) error

        // Send transmits a message over the transport.
        Send(data []byte) error

        // SetErrorHandler sets the handler for transport errors.
        SetErrorHandler(handler ErrorHandler)
}

// RequestHandler handles incoming requests
type RequestHandler func(ctx context.Context, params interface{}) (interface{}, error)

// NotificationHandler handles incoming notifications
type NotificationHandler func(ctx context.Context, params interface{}) error

// ErrUnsupportedMethod is returned when a method is not supported
var ErrUnsupportedMethod = errors.New("unsupported method")

// BaseTransport provides common functionality for transports
type BaseTransport struct {
        sync.RWMutex
        requestHandlers      map[string]RequestHandler
        notificationHandlers map[string]NotificationHandler
        progressHandlers     map[string]ProgressHandler
        nextID               int64
        pendingRequests      map[string]chan *protocol.Response
        logger               *log.Logger
}

// NewBaseTransport creates a new BaseTransport
func NewBaseTransport() *BaseTransport <span class="cov8" title="1">{
        return &amp;BaseTransport{
                requestHandlers:      make(map[string]RequestHandler),
                notificationHandlers: make(map[string]NotificationHandler),
                progressHandlers:     make(map[string]ProgressHandler),
                nextID:               1,
                pendingRequests:      make(map[string]chan *protocol.Response),
                logger:               log.New(os.Stderr, "BaseTransport: ", log.LstdFlags|log.Lshortfile),
        }
}</span>

// SetLogger sets a custom logger for the BaseTransport.
func (t *BaseTransport) SetLogger(logger *log.Logger) <span class="cov0" title="0">{
        t.Lock()
        defer t.Unlock()
        t.logger = logger
}</span>

// Logf logs a formatted string using the transport's logger.
func (t *BaseTransport) Logf(format string, v ...interface{}) <span class="cov8" title="1">{
        t.RLock()
        logger := t.logger
        t.RUnlock()
        if logger != nil </span><span class="cov8" title="1">{
                logger.Printf(format, v...)
        }</span>
}

// RegisterRequestHandler registers a handler for incoming requests
func (t *BaseTransport) RegisterRequestHandler(method string, handler RequestHandler) <span class="cov8" title="1">{
        t.Lock()
        defer t.Unlock()
        t.requestHandlers[method] = handler
}</span>

// RegisterNotificationHandler registers a handler for incoming notifications
func (t *BaseTransport) RegisterNotificationHandler(method string, handler NotificationHandler) <span class="cov8" title="1">{
        t.Lock()
        defer t.Unlock()
        t.notificationHandlers[method] = handler
}</span>

// GetNextID returns the next unique request ID
func (t *BaseTransport) GetNextID() int64 <span class="cov8" title="1">{
        t.Lock()
        defer t.Unlock()
        id := t.nextID
        t.nextID++
        return id
}</span>

// WaitForResponse waits for a response with the specified ID
func (t *BaseTransport) WaitForResponse(ctx context.Context, id interface{}) (*protocol.Response, error) <span class="cov8" title="1">{
        ch := make(chan *protocol.Response, 1)

        // Ensure id is a string for map key consistency
        stringID := fmt.Sprintf("%v", id)

        t.Lock()
        t.pendingRequests[stringID] = ch
        t.Unlock()

        defer func() </span><span class="cov8" title="1">{
                t.Lock()
                delete(t.pendingRequests, stringID)
                t.Unlock()
        }</span>()

        <span class="cov8" title="1">select </span>{
        case resp := &lt;-ch:<span class="cov8" title="1">
                return resp, nil</span>
        case &lt;-ctx.Done():<span class="cov8" title="1">
                return nil, ctx.Err()</span>
        }
}

// HandleResponse handles an incoming response
func (t *BaseTransport) HandleResponse(resp *protocol.Response) <span class="cov8" title="1">{
        // Convert response ID to string for consistent map lookup
        stringID := fmt.Sprintf("%v", resp.ID)

        t.RLock()
        ch, ok := t.pendingRequests[stringID]
        pendingReqsCount := len(t.pendingRequests)
        t.RUnlock()

        t.Logf("HandleResponse: Received response for ID '%s' (original: %v, type: %T). Pending requests: %d. Channel found: %t", stringID, resp.ID, resp.ID, pendingReqsCount, ok)

        if ok </span><span class="cov8" title="1">{
                select </span>{
                case ch &lt;- resp:<span class="cov8" title="1">
                        t.Logf("HandleResponse: Successfully sent response for ID '%s' to channel.", stringID)</span>
                default:<span class="cov0" title="0">
                        // Response channel is full or closed, or context expired waiting for send
                        t.Logf("HandleResponse: Failed to send response for ID '%s' to channel (channel full, closed, or context expired).", stringID)</span>
                }
        } else<span class="cov0" title="0"> {
                t.Logf("HandleResponse: No pending request found for response ID '%s'.", stringID)
        }</span>
}

// HandleRequest processes an incoming request
func (t *BaseTransport) HandleRequest(ctx context.Context, req *protocol.Request) (response *protocol.Response, err error) <span class="cov8" title="1">{
        // Recover from panics and convert to proper error response
        defer func() </span><span class="cov8" title="1">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        stackTrace := string(debug.Stack())
                        t.Logf("ERROR: Panic in HandleRequest for method %s: %v\nStack trace:\n%s", req.Method, r, stackTrace)
                        response, err = protocol.NewErrorResponse(req.ID, protocol.InternalError,
                                fmt.Sprintf("Internal server error processing %s", req.Method), nil)
                }</span>
        }()

        <span class="cov8" title="1">t.RLock()
        handler, ok := t.requestHandlers[req.Method]
        t.RUnlock()

        if !ok </span><span class="cov8" title="1">{
                return protocol.NewErrorResponse(req.ID, protocol.MethodNotFound, fmt.Sprintf("Method not found: %s", req.Method), nil)
        }</span>

        // Params are passed through directly to the handler
        // The handler will determine how to interpret the params
        <span class="cov8" title="1">params := req.Params

        result, err := handler(ctx, params)
        if err != nil </span><span class="cov8" title="1">{
                return protocol.NewErrorResponse(req.ID, protocol.InternalError, err.Error(), nil)
        }</span>

        <span class="cov8" title="1">return protocol.NewResponse(req.ID, result)</span>
}

// HandleNotification processes an incoming notification
func (t *BaseTransport) HandleNotification(ctx context.Context, notif *protocol.Notification) (err error) <span class="cov8" title="1">{
        // Recover from panics in notification handlers
        defer func() </span><span class="cov8" title="1">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        stackTrace := string(debug.Stack())
                        t.Logf("ERROR: Panic in HandleNotification for method %s: %v\nStack trace:\n%s", notif.Method, r, stackTrace)
                        err = fmt.Errorf("internal error processing notification %s: %v", notif.Method, r)
                }</span>
        }()

        // Special handling for progress notifications
        <span class="cov8" title="1">if notif.Method == protocol.MethodProgress &amp;&amp; len(notif.Params) &gt; 0 </span><span class="cov8" title="1">{
                // Extract the request ID from the progress params
                var progressParams protocol.ProgressParams
                if err := json.Unmarshal(notif.Params, &amp;progressParams); err == nil &amp;&amp; progressParams.ID != nil </span><span class="cov8" title="1">{
                        // Convert ID to string for map lookup
                        idStr := fmt.Sprintf("%v", progressParams.ID)

                        // Find and call progress handler if registered
                        t.RLock()
                        handler, ok := t.progressHandlers[idStr]
                        t.RUnlock()

                        if ok </span><span class="cov8" title="1">{
                                return handler(notif.Params)
                        }</span>
                }
        }

        // Regular notification handling
        <span class="cov8" title="1">t.RLock()
        handler, ok := t.notificationHandlers[notif.Method]
        t.RUnlock()

        if !ok </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: %s", ErrUnsupportedMethod, notif.Method)
        }</span>

        <span class="cov8" title="1">return handler(ctx, notif.Params)</span>
}

// DefaultTimeout is the default timeout for requests
const DefaultTimeout = 30 * time.Second

// SafeGo runs a function in a goroutine with panic recovery
func SafeGo(logger func(format string, args ...interface{}), name string, fn func()) <span class="cov8" title="1">{
        go func() </span><span class="cov8" title="1">{
                defer func() </span><span class="cov8" title="1">{
                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                stackTrace := string(debug.Stack())
                                logger("ERROR: Panic in goroutine %s: %v\nStack trace:\n%s", name, r, stackTrace)
                        }</span>
                }()
                <span class="cov8" title="1">fn()</span>
        }()
}

// Options contains configuration options for transports
type Options struct {
        RequestTimeout time.Duration
}

// Option is a function that sets an option
type Option func(*Options)

// WithRequestTimeout sets the request timeout
func WithRequestTimeout(timeout time.Duration) Option <span class="cov8" title="1">{
        return func(opts *Options) </span><span class="cov8" title="1">{
                opts.RequestTimeout = timeout
        }</span>
}

// RegisterProgressHandler registers a handler for progress notifications
func (t *BaseTransport) RegisterProgressHandler(id interface{}, handler ProgressHandler) <span class="cov8" title="1">{
        idStr := fmt.Sprintf("%v", id)

        t.Lock()
        defer t.Unlock()
        t.progressHandlers[idStr] = handler
}</span>

// UnregisterProgressHandler removes a progress handler
func (t *BaseTransport) UnregisterProgressHandler(id interface{}) <span class="cov8" title="1">{
        idStr := fmt.Sprintf("%v", id)

        t.Lock()
        defer t.Unlock()
        delete(t.progressHandlers, idStr)
}</span>

// GenerateID generates a unique string ID for requests
func (t *BaseTransport) GenerateID() string <span class="cov8" title="1">{
        return fmt.Sprintf("%d", t.GetNextID())
}</span>

// NewOptions creates default options
func NewOptions(options ...Option) *Options <span class="cov8" title="1">{
        opts := &amp;Options{
                RequestTimeout: DefaultTimeout,
        }

        for _, option := range options </span><span class="cov8" title="1">{
                option(opts)
        }</span>

        <span class="cov8" title="1">return opts</span>
}
</pre>

		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
